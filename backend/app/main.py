from fastapi import FastAPI, Depends  # Import FastAPI class and Depends function from fastapi module
from sqlalchemy.orm import Session # Import Session class from sqlalchemy.orm module
from app.database import engine , get_db # Import the database engine and get_db function
from app.models import Task, Organization, User # Import the models
from pydantic import BaseModel # Import BaseModel for request validation
from app.security import hash_password, verify_password # Import security functions
from app.auth import create_access_token # Import function to create access tokens


# Pydantic models for request validation
class OrganizationCreate(BaseModel):
    name: str

class TaskCreate(BaseModel):
    title: str
    status: str
    organization_id: int

app = FastAPI() # Create an instance of FastAPI

@app.get("/") # Define a GET endpoint at root
def root():
    return {
        "message": "Taskflow API", 
        "endpoints": {
            "health": "/health",
            "tasks": "/tasks",
            "docs": "/docs"
        }
    }

@app.get("/health") # Define a GET endpoint at /health
def health(): # Define the health function
    return {"status": "OK"} # Return a JSON response indicating the service is healthy

@app.post("/organizations") # Create organization endpoint
def create_organization(org_data: OrganizationCreate, db: Session = Depends(get_db)):
    org = Organization(**org_data.model_dump())
    db.add(org)
    db.commit()
    db.refresh(org)
    return org

@app.get("/tasks") # Registers a GET endpoint at /tasks
def get_tasks(db: Session = Depends(get_db)): # FastAPI calls get_db(), injects a DB session and cleans it up after the request
    tasks = db.query(Task).all() # Query all tasks from the database, translates to SQL: SELECT * FROM tasks; "ORM -> SQL -> DB -> SQL Result -> ORM Objects"
    return tasks # Return the list of tasks as JSON
# 1. Client hits /tasks
# 2. FastAPI calls get_db()
# 3. Injects db session
# 4. ORM runs SELECT * FROM tasks
# 5. Results returned as JSON

@app.post("/tasks") # Registers a POST endpoint at /tasks
def create_task(task_data: TaskCreate, db: Session=Depends(get_db)): # FastAPI calls get_db(), injects a DB session and cleans it up after the request
    task=Task(**task_data.model_dump()) # Create a new Task instance from the provided data
    db.add(task) # Stage the new task for insertion into the db, does not hit the DB yet
    db.commit() # Executes SQL INSERT, permanently stores data
    db.refresh(task) # Reloads data from db to get any autogenerated db fields (like ID,timestamps),REFRESH: To sync ORM object with DB-generated values.
    return task # Return the newly created task as JSON

# 1. task_data → JSON body from client
# 2. Task(**task_data) → creates ORM object
# 3. add() → stages insert
# 4. commit() → writes to DB
# 5. refresh() → loads DB-generated values (id, timestamp)

app.post("/signup") # User signup endpoint
def signup_user(user_data: dict, db:Session=Depends(get_db)): # FastAPI calls get_db(), injects a DB session and cleans it up after the request
    hashed_pwd=hash_password(user_data["password"]) # Hash the user's password

    user=User(email=user_data["email"], hashed_password=hashed_pwd, role=user_data.get("role","user"), organization_id=user_data["organization_id"]) # Create a new User instance
    db.add(user) # Stage the new user for insertion into the db
    db.commit() # Execute SQL INSERT, permanently stores data
    db.refresh(user) # Reloads data from db to get any autogenerated db fields (like ID,timestamps),REFRESH: To sync ORM object with DB-generated values.

    return {
        "id": user.id,
        "email": user.email,
        "role": user.role,
        "organization_id": user.organization_id
    } # Return the newly created user details as JSON (excluding password)

@app.post("/login") # User login endpoint
def login_user(credentials: dict, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.email == credentials["email"]).first()

    if not user:
        return {"error": "Invalid credentials"}

    if not verify_password(credentials["password"], user.hashed_password):
        return {"error": "Invalid credentials"}

    token = create_access_token({
        "user_id": user.id,
        "organization_id": user.organization_id,
        "role": user.role
    })

    return {"access_token": token}